<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>SP8D Advanced Protocol Test Harness</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link
      href="https://fonts.googleapis.com/css?family=Roboto:400,500,700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* =====================
         CSS Custom Properties
         ===================== */
      :root {
        --color-bg: #f8fafd;
        --color-header-bg: #1a2233;
        --color-header-fg: #f8fafd;
        --color-header-sub: #e2e6ee;
        --color-header-desc: #b3b7be;
        --color-accent: #19c37d;
        --color-accent-hover: #159a60;
        --color-fail: #e04446;
        --color-card-bg: #fff;
        --color-card-border: rgba(25, 195, 125, 0.18);
        --color-card-hover: #f3f6fa;
        --color-metric-bg: #f3f6fa;
        --color-footer: #b3b7be;
        --font-main: "Inter", "Roboto", Arial, sans-serif;
        --font-mono: "Roboto Mono", "Menlo", "Consolas", monospace;
        --font-size-base: 1.125rem;
        --font-size-lg: 2.2rem;
        --font-size-md: 1.18rem;
        --font-size-sm: 1.01rem;
        --radius: 8px;
        --radius-sm: 4px;
        --transition: 0.18s cubic-bezier(0.4, 0, 0.2, 1);
        --transition-card: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        --space: 2.5rem;
        --space-sm: 1.5rem;
        --space-xs: 0.7rem;
      }

      /* ========== Base ========== */
      html {
        box-sizing: border-box;
        font-size: var(--font-size-base);
        background: var(--color-bg);
      }
      *,
      *:before,
      *:after {
        box-sizing: inherit;
      }
      body {
        background: var(--color-bg);
        margin: 0;
        font-family: var(--font-main);
        color: var(--color-header-bg);
        min-height: 100vh;
        line-height: 1.7;
      }

      /* ========== Header ========== */
      header {
        background: var(--color-header-bg);
        color: var(--color-header-fg);
        padding: var(--space) var(--space) var(--space-sm) var(--space);
        border-bottom: 2px solid var(--color-accent);
        text-align: center;
        position: relative;
      }
      .header-title {
        font-size: var(--font-size-lg);
        font-weight: 700;
        letter-spacing: -0.5px;
        margin: 0 0 0.4rem 0;
        line-height: 1.1;
      }
      .header-sub {
        font-size: 1.15rem;
        font-weight: 400;
        margin: 0 0 0.5rem 0;
        color: var(--color-header-sub);
        opacity: 0.95;
        max-width: 700px;
        margin-left: auto;
        margin-right: auto;
      }
      .header-desc {
        font-size: var(--font-size-sm);
        color: var(--color-header-desc);
        margin: 0;
        max-width: 700px;
        font-weight: 400;
        margin-left: auto;
        margin-right: auto;
      }
      .header-links {
        display: flex;
        justify-content: center;
        gap: 1.5rem;
        margin-top: var(--space-xs);
        position: static;
      }
      .header-link {
        color: var(--color-header-desc);
        font-weight: 500;
        font-size: 1.05rem;
        text-decoration: none;
        transition: color var(--transition);
        opacity: 0.92;
      }
      .header-link:focus,
      .header-link:hover {
        color: var(--color-header-fg);
        text-decoration: none;
        opacity: 1;
      }

      /* ========== Main Layout ========== */
      main {
        max-width: 820px;
        margin: 0 auto;
        padding: var(--space) 1.5rem 0 1.5rem;
      }
      .tests {
        margin: var(--space) 0 var(--space-sm) 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--space);
      }

      /* ========== Test Cards ========== */
      .testcase {
        border: 1px solid var(--color-card-border);
        border-left: 4px solid var(--color-accent);
        background: var(--color-card-bg);
        margin-bottom: 0;
        padding: var(--space-sm) var(--space-sm) 1.2rem var(--space-sm);
        border-radius: var(--radius);
        box-shadow: none;
        position: relative;
        width: 100%;
        max-width: 700px;
        display: flex;
        flex-direction: column;
        gap: 0.7rem;
        transition: background var(--transition-card);
      }
      .testcase:focus-within,
      .testcase:hover {
        background: var(--color-card-hover);
      }
      .testcase-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
      }
      .testcase-header h2 {
        margin: 0;
        font-size: var(--font-size-md);
        font-weight: 600;
        color: var(--color-header-bg);
      }
      .test-desc {
        color: #3a4255;
        font-size: var(--font-size-sm);
        margin-bottom: 0.2em;
        max-width: 650px;
      }
      .runbtn {
        align-self: flex-end;
        background: var(--color-accent);
        color: #fff;
        border: none;
        border-radius: var(--radius-sm);
        padding: 0.6em 1.5em;
        font-size: 1.05rem;
        cursor: pointer;
        font-weight: 600;
        margin-top: 0.2rem;
        margin-bottom: 0.2rem;
        transition: background var(--transition);
        box-shadow: none;
      }
      .runbtn:focus,
      .runbtn:active,
      .runbtn:hover {
        background: var(--color-accent-hover);
      }
      .runbtn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* ========== Metrics & Output ========== */
      .metricbar {
        margin: 0.3rem 0 0.1rem 0;
        display: flex;
        gap: 1.5rem;
        flex-wrap: wrap;
      }
      .metric {
        font-family: var(--font-mono);
        font-size: 1.05rem;
        color: var(--color-header-bg);
        padding: 0.1rem 0.7rem 0.1rem 0.7rem;
        background: var(--color-metric-bg);
        border-radius: var(--radius-sm);
        min-width: 90px;
        text-align: center;
        border: none;
        display: flex;
        align-items: center;
        gap: 0.5em;
      }
      .dot {
        display: inline-block;
        width: 0.75em;
        height: 0.75em;
        border-radius: 50%;
        margin-right: 0.4em;
      }
      .dot-success {
        background: var(--color-accent);
      }
      .dot-fail {
        background: var(--color-fail);
      }
      .live-output {
        background: var(--color-header-bg);
        color: var(--color-header-fg);
        font-size: var(--font-size-sm);
        padding: 0.8em 1em;
        border-radius: 6px;
        font-family: var(--font-mono);
        max-height: 100px;
        overflow: auto;
        letter-spacing: 0.01em;
        transition: background var(--transition), color var(--transition);
      }
      .success {
        color: var(--color-accent) !important;
        font-weight: 600;
      }
      .fail {
        color: var(--color-fail) !important;
        font-weight: 600;
      }
      .case-footer {
        font-size: 0.97rem;
        color: #3a4255;
        margin: 0.5em 0 0.1em 0;
        opacity: 0.7;
        font-style: italic;
      }

      /* ========== Links & Accessibility ========== */
      a {
        color: var(--color-accent);
        text-decoration: none;
        font-weight: 500;
        transition: color var(--transition);
      }
      a:focus,
      a:hover {
        color: var(--color-accent-hover);
      }
      button:focus-visible {
        outline: 2px solid var(--color-accent);
      }

      /* ========== Responsive ========== */
      @media (max-width: 700px) {
        main {
          padding: 0.5rem 0.18rem 0 0.18rem;
        }
        .testcase {
          padding: 1rem 0.8rem 0.7rem 0.7rem;
        }
        .runbtn {
          margin-left: 0.5rem;
          margin-top: 0.5rem;
          margin-bottom: 0.5rem;
        }
        .metricbar {
          flex-direction: column;
          gap: 0.6rem;
        }
        .header-links {
          position: static;
          justify-content: center;
          margin-top: var(--space-xs);
          right: 0;
          top: 0;
        }
      }

      /* ========== Utility & Misc ========== */
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }
      footer {
        text-align: center;
        font-size: 1rem;
        color: var(--color-footer);
        margin-top: 1.2rem;
        padding: 0.7rem 0 0.3rem 0;
      }
      hr {
        margin-top: 2.8em;
        margin-bottom: 0;
        border: 0;
        border-top: 1px solid var(--color-accent);
        opacity: 0.18;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-title">SP8D Protocol — Advanced Test Harness</div>
      <div class="header-sub">
        SP8D is a high-performance, robust browser protocol for safe, lossless,
        and concurrent message passing—designed for demanding AI and data
        science copilots.
      </div>
      <div class="header-desc">
        <b>How to use:</b> Click <b>Run</b> on any test to simulate real-world
        browser concurrency scenarios. Results update live below each test.<br />
        <b>Legend:</b> <span class="dot dot-success"></span>Pass,
        <span class="dot dot-fail"></span>Fail.
      </div>
      <div class="header-links">
        <a
          class="header-link"
          href="https://github.com/SP8D/sp8d"
          target="_blank"
          >GitHub</a
        >
        <a
          class="header-link"
          href="https://www.npmjs.com/package/@sp8d/core"
          target="_blank"
          >npm</a
        >
      </div>
    </header>
    <main>
      <section
        id="diagnostics-dashboard"
        style="
          margin-bottom: 2.5rem;
          min-height: 60px;
          background: #f3f6fa;
          border: 1px solid #e2e6ee;
          border-radius: 8px;
          padding: 1rem 0 0.5rem 0;
        "
      >
        <div
          id="diag-global"
          style="
            display: flex;
            gap: 1.5rem;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 0.7rem;
            min-height: 28px;
          "
        >
          Loading diagnostics…
        </div>
        <div
          id="diag-slotgrid"
          style="
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(18px, 1fr));
            gap: 2px;
            max-width: 700px;
          "
        ></div>
      </section>
      <section class="tests">
        <div class="testcase" id="case1">
          <div class="testcase-header">
            <h2>1. <b>Live High-Throughput Stress</b></h2>
            <button class="runbtn" onclick="runStressTest(this)">▶ Run</button>
          </div>
          <div class="test-desc">
            <b>Scenario:</b> Simulates 5,000 message events between async
            producer and consumer, measuring actual messages processed and time
            to completion.<br />
            <b>Why It Matters:</b> Legacy <code>postMessage</code> or event bus
            patterns collapse well below this throughput. Real data science
            copilots require <b>thousands/sec without UI freezes</b>.
          </div>
          <div class="metricbar">
            <span class="metric" id="stress_result">Not run</span>
          </div>
          <div class="live-output" id="stress_output">
            Duration: - ms Lost: -
          </div>
          <div class="case-footer">
            Key metric: throughput, no missed/lost messages, no lag.
          </div>
        </div>

        <div class="testcase" id="case2">
          <div class="testcase-header">
            <h2>2. <b>Slot Reclamation & Stale-Job Handling</b></h2>
            <button class="runbtn" onclick="runReclaimTest(this)">▶ Run</button>
          </div>
          <div class="test-desc">
            <b>Scenario:</b> Intentionally abandons some job slots to see if
            protocol reclaims memory/slots automatically.<br />
            <b>Why It Matters:</b> This is vital for long-running browser
            sessions&mdash;leaks or stuck jobs can creep in and kill
            reliability.
          </div>
          <div class="metricbar">
            <span class="metric" id="reclaim_result">Not run</span>
          </div>
          <div class="live-output" id="reclaim_output">
            Reclaimed: -, Errors: - Free slots after: -
          </div>
          <div class="case-footer">
            Key metric: Reclaimed slot count, protocol recovery visible in logs.
          </div>
        </div>

        <div class="testcase" id="case3">
          <div class="testcase-header">
            <h2>3. <b>Race Condition & Conflict Resolution</b></h2>
            <button class="runbtn" onclick="runRaceTest(this)">▶ Run</button>
          </div>
          <div class="test-desc">
            <b>Scenario:</b> Multiple producers and consumers hammer the shared
            channel, purposely colliding on slots.
            <br />
            <b>Why It Matters:</b> Race bugs in message-passing systems are the
            #1 hidden browser reliability risk. SP8D must resolve conflicts
            cleanly.
          </div>
          <div class="metricbar">
            <span class="metric" id="race_result">Not run</span>
          </div>
          <div class="live-output" id="race_output">
            Produced: -, Consumed: -, Conflicts: -, Errors: -
          </div>
          <div class="case-footer">
            Key metric: # of resolved conflicts and error count.
          </div>
        </div>

        <div class="testcase" id="case4">
          <div class="testcase-header">
            <h2>4. <b>Protocol Correctness & Data Integrity</b></h2>
            <button class="runbtn" onclick="runCorrectTest(this)">▶ Run</button>
          </div>
          <div class="test-desc">
            <b>Scenario:</b> Sends randomized messages and checks every output
            for corruption, order, duplicates, or loss.
            <br />
            <b>Why It Matters:</b> Real-world browsers lose/corrupt data under
            stress if protocol is weak—financial workflows can't tolerate this.
          </div>
          <div class="metricbar">
            <span class="metric" id="correct_result">Not run</span>
          </div>
          <div class="live-output" id="correct_output">
            Sent: -, Received: -, Fail? No
          </div>
          <div class="case-footer">
            Key metric: end-to-end message correctness, reports first failure.
          </div>
        </div>
      </section>
      <hr />
    </main>
    <footer>
      <span style="font-size: 0.97rem; opacity: 0.7"
        >Review the <b>test source</b> on
        <a
          href="https://github.com/SP8D/sp8d/tree/main/packages/core/test/index.html"
          target="_blank"
          >GitHub</a
        >
        for more details.</span
      >
    </footer>
    <script type="module">
      import { createChannel } from "../dist/sp8d-core.js";
      // Helper: encode/decode for message passing
      const encode = (obj, size = 80) => {
        const s = JSON.stringify(obj);
        const b = new TextEncoder().encode(s);
        const arr = new Uint8Array(size);
        arr.set(b.slice(0, size));
        return arr;
      };
      const decode = (arr) =>
        JSON.parse(new TextDecoder().decode(arr).replace(/\0+$/g, ""));

      // --- TEST CASES ---
      window.runStressTest = async (btn) => {
        btn.disabled = true;
        const N = 5000,
          slots = 16,
          size = 80;
        let processed = 0,
          sent = 0;
        const { channel, buffer } = createChannel({
          slots,
          slotSize: size,
          sweepTimeoutMs: 40,
        });
        // No live diagnostics during the test
        const start = Date.now();
        // Producer
        const prod = setInterval(() => {
          for (let tries = 0; tries < 100 && sent < N; tries++)
            if (channel.send(encode({ i: sent }))) sent++;
        }, 0);
        // Consumer
        const cons = setInterval(() => {
          let msg;
          while ((msg = channel.recv())) processed++;
        }, 0);
        const timeout = 2500,
          t0 = Date.now();
        while (processed < N && Date.now() - t0 < timeout)
          await new Promise((r) => setTimeout(r, 10));
        clearInterval(prod);
        clearInterval(cons);
        const duration = Date.now() - start;
        document.getElementById("stress_result").innerHTML =
          (processed === N
            ? '<span class="success">PASS — '
            : '<span class="fail">FAIL — ') +
          `Processed ${processed}/${N} (${((processed / N) * 100).toFixed(
            1
          )}%)</span>`;
        document.getElementById(
          "stress_output"
        ).textContent = `Duration: ${duration} ms\nLost: ${N - processed}`;
        // Take a single diagnostics sample at the end
        const stats = channel.stats();
        const avgThroughput = duration > 0 ? processed / (duration / 1000) : 0;
        diagSummary = {
          peakThroughput: avgThroughput,
          avgThroughput,
          maxLag: 0,
          totalConflicts: stats.conflicts,
          totalErrors: stats.errors,
          totalReclaimed: stats.reclaimed,
          finalSlotState: [],
          slots,
        };
        diagTestActive = false;
        updateDiagnosticsDashboard();
        btn.disabled = false;
      };

      window.runReclaimTest = async (btn) => {
        btn.disabled = true;
        const slots = 12,
          size = 80;
        const { channel, buffer } = createChannel({
          slots,
          slotSize: size,
          sweepTimeoutMs: 10,
        });
        startDiagnostics({ buffer }, slots);
        Object.defineProperty(channel, "slotStatus", {
          value: channel["slotStatus"],
          writable: false,
          configurable: true,
          enumerable: false,
        });
        Object.defineProperty(channel, "slotClaimTimestamp", {
          value: channel["slotClaimTimestamp"],
          writable: false,
          configurable: true,
          enumerable: false,
        });
        for (let i = 0; i < slots / 2; i++) {
          channel.slotStatus[0][i] = 1;
          channel.slotClaimTimestamp[0][i] = Date.now() - 1000;
        }
        await new Promise((r) => setTimeout(r, 1000));
        const preReclaimed = 0;
        const stats = channel.stats();
        document.getElementById("reclaim_result").innerHTML =
          (stats.reclaimed > preReclaimed
            ? '<span class="success">PASS — '
            : '<span class="fail">FAIL — ') +
          `Slots Reclaimed: ${stats.reclaimed - preReclaimed}</span>`;
        document.getElementById("reclaim_output").textContent = `Reclaimed: ${
          stats.reclaimed - preReclaimed
        }, Errors: ${stats.errors}\nFree slots after: ${stats.free}`;
        // Use final stats for dashboard summary
        diagSummary = {
          peakThroughput: 0,
          avgThroughput: 0,
          maxLag: 0,
          totalConflicts: stats.conflicts,
          totalErrors: stats.errors,
          totalReclaimed: stats.reclaimed,
          finalSlotState: [],
          slots,
        };
        diagTestActive = false;
        updateDiagnosticsDashboard();
        btn.disabled = false;
      };

      window.runRaceTest = async (btn) => {
        btn.disabled = true;
        const producers = 12,
          consumers = 12,
          slots = 2,
          size = 80,
          N = 2000;
        let written = 0,
          read = 0;
        const { channel, buffer } = createChannel({
          slots,
          slotSize: size,
          sweepTimeoutMs: 30,
        });
        startDiagnostics({ buffer }, slots);
        channel.__getTestStats = () => ({
          errors: channel.errors,
          conflicts: channel.conflicts,
        });
        const start = Date.now(); // Record actual start time
        const prodInt = Array.from({ length: producers }, (_, p) =>
          setInterval(() => {
            for (let c = 0; c < 100 && written < N; c++)
              if (channel.send(encode({ w: written }, size))) written++;
          }, 1)
        );
        const consInt = Array.from({ length: consumers }, (_, c) =>
          setInterval(() => {
            let msg;
            while ((msg = channel.recv())) read++;
          }, 1)
        );
        const timeout = 3000;
        while (read < N && Date.now() - start < timeout)
          await new Promise((r) => setTimeout(r, 10));
        prodInt.forEach(clearInterval);
        consInt.forEach(clearInterval);
        const { conflicts, errors } = channel.__getTestStats();
        document.getElementById("race_result").innerHTML =
          (conflicts > 0 || errors > N / 2
            ? '<span class="success">PASS — '
            : '<span class="fail">FAIL — ') +
          `Conflicts detected: ${conflicts}, Errors: ${errors}`;
        document.getElementById(
          "race_output"
        ).textContent = `Produced: ${written}, Consumed: ${read}, Conflicts: ${conflicts}, Errors: ${errors}`;
        const duration = Date.now() - start; // Use actual measured duration
        const stats = channel.stats();
        const avgThroughput = duration > 0 ? written / (duration / 1000) : 0;
        diagSummary = {
          peakThroughput: avgThroughput,
          avgThroughput,
          maxLag: 0,
          totalConflicts: stats.conflicts,
          totalErrors: stats.errors,
          totalReclaimed: stats.reclaimed,
          finalSlotState: [],
          slots,
        };
        diagTestActive = false;
        updateDiagnosticsDashboard();
        btn.disabled = false;
      };

      window.runCorrectTest = async (btn) => {
        btn.disabled = true;
        const slots = 32,
          size = 80,
          N = 30;
        const sent = [],
          got = [];
        const { channel, buffer } = createChannel({
          slots,
          slotSize: size,
          sweepTimeoutMs: 50,
        });
        startDiagnostics({ buffer }, slots);
        for (let i = 0; i < N; i++) {
          const obj = { msg: i, rnd: Math.random() };
          sent.push(obj);
          channel.send(encode(obj, size));
        }
        let broken = null;
        const start = Date.now();
        for (let tr = 0; tr < 200 && got.length < N && !broken; tr++) {
          let out;
          while ((out = channel.recv())) {
            const obj = decode(out);
            got.push(obj);
            const ref = sent[obj.msg];
            if (!ref || ref.rnd !== obj.rnd) broken = obj;
          }
          await new Promise((r) => setTimeout(r, 50));
        }
        document.getElementById("correct_result").innerHTML = broken
          ? '<span class="fail">FAIL — Data Corruption!</span>'
          : got.length === N
          ? '<span class="success">PASS — All messages correct!</span>'
          : '<span class="fail">FAIL — Message Loss</span>';
        document.getElementById("correct_output").textContent =
          `Sent: ${N}, Received: ${got.length}, Fail? ${
            broken ? JSON.stringify(broken) : "No"
          }` +
          (broken
            ? `\nMISMATCH: got ${JSON.stringify(broken)} expected rnd=${
                sent[broken.msg] && sent[broken.msg].rnd
              }`
            : "");
        // Use final stats for dashboard summary
        const duration = Date.now() - start;
        const stats = channel.stats();
        const avgThroughput = duration > 0 ? got.length / (duration / 1000) : 0;
        diagSummary = {
          peakThroughput: avgThroughput,
          avgThroughput,
          maxLag: 0,
          totalConflicts: stats.conflicts,
          totalErrors: stats.errors,
          totalReclaimed: stats.reclaimed,
          finalSlotState: [],
          slots,
        };
        diagTestActive = false;
        updateDiagnosticsDashboard();
        btn.disabled = false;
      };

      // --- DIAGNOSTICS DASHBOARD INTEGRATION ---
      let diagWorker = null;
      let diagStats = {};
      let diagHistory = [];
      let diagSummary = null;
      let diagTestActive = false;
      let diagLastUpdate = 0;
      function startDiagnostics(channel, slots, opts = {}) {
        if (diagWorker) diagWorker.terminate();
        diagWorker = new Worker("./sp8d-diagnostics-worker.js", {
          type: "module",
        });
        diagHistory = [];
        diagSummary = null;
        diagTestActive = true;
        diagLastUpdate = 0;
        // For stress tests, use slower interval and skip slotState
        const intervalMs = opts.intervalMs ?? 200;
        const slotSample = opts.slotSample ?? 0; // 0 disables slotState
        diagWorker.postMessage({
          buffer: channel.buffer || channel.sab,
          options: { intervalMs, slotSample },
        });
        diagWorker.onmessage = (e) => {
          // Throttle UI updates to every 200ms
          const now = Date.now();
          if (now - diagLastUpdate < 200 && diagTestActive) return;
          diagLastUpdate = now;
          diagStats = e.data;
          if (diagTestActive)
            diagHistory.push({
              throughput: diagStats.throughput,
              consumerLag: diagStats.consumerLag,
              conflicts: diagStats.conflicts,
              errors: diagStats.errors,
              reclaimed: diagStats.reclaimed,
            });
          updateDiagnosticsDashboard();
        };
      }
      function endDiagnosticsSummary(testMeta = {}) {
        diagTestActive = false;
        if (!diagHistory.length) return;
        // Compute summary using actual test duration and processed count
        const { processed = 0, durationMs = 0 } = testMeta;
        let peakThroughput = 0,
          sumThroughput = 0,
          maxLag = 0,
          total = diagHistory.length;
        let totalConflicts = 0,
          totalErrors = 0,
          totalReclaimed = 0;
        for (const s of diagHistory) {
          peakThroughput = Math.max(peakThroughput, s.throughput || 0);
          sumThroughput += s.throughput || 0;
          maxLag = Math.max(maxLag, s.consumerLag || 0);
          totalConflicts += s.conflicts || 0;
          totalErrors += s.errors || 0;
          totalReclaimed += s.reclaimed || 0;
        }
        // Use actual test throughput
        const avgThroughput =
          durationMs > 0 ? processed / (durationMs / 1000) : 0;
        // Use final lag from last sample
        const last = diagHistory[diagHistory.length - 1] || {};
        diagSummary = {
          peakThroughput,
          avgThroughput,
          maxLag: last.consumerLag || 0,
          totalConflicts,
          totalErrors,
          totalReclaimed,
          finalSlotState: [], // not sampled for stress
          slots: testMeta.slots || 0,
        };
        updateDiagnosticsDashboard();
      }
      function updateDiagnosticsDashboard() {
        const stats = diagTestActive ? diagStats : diagSummary || {};
        const global = document.getElementById("diag-global");
        if (!stats || (!stats.slots && !stats.peakThroughput)) {
          global.innerHTML =
            '<span style="color:#888">Diagnostics will appear here when a test is running.</span>';
          document.getElementById("diag-slotgrid").innerHTML = "";
          return;
        }
        if (!diagTestActive && diagSummary) {
          // Show summary
          global.innerHTML = `
            <span class="metric"><b>Peak Throughput</b>: ${
              diagSummary.peakThroughput > 0
                ? diagSummary.peakThroughput.toFixed(1)
                : diagSummary.avgThroughput.toFixed(1)
            } msg/s</span>
            <span class="metric"><b>Avg Throughput</b>: ${diagSummary.avgThroughput.toFixed(
              1
            )} msg/s</span>
            <span class="metric"><b>Max Lag</b>: ${diagSummary.maxLag} ms</span>
            <span class="metric"><b>Total Conflicts</b>: ${
              diagSummary.totalConflicts
            }</span>
            <span class="metric"><b>Total Errors</b>: ${
              diagSummary.totalErrors
            }</span>
            <span class="metric"><b>Total Reclaimed</b>: ${
              diagSummary.totalReclaimed
            }</span>
          `;
          // Slot grid: show only non-empty slots, or a healthy message
          const N = diagSummary.slots || 0;
          const slotState = diagSummary.finalSlotState || [];
          let nonEmpty = slotState.filter((s) => s && s.status !== 0);
          let slotHtml = "";
          if (N && nonEmpty.length === 0) {
            slotHtml = `<div style="color:#19c37d;font-weight:600;padding:0.5em 0;">All slots healthy (empty)</div>`;
          } else if (N) {
            for (let i = 0; i < N; i++) {
              const slot = slotState[i] || { status: 0 };
              let color =
                slot.status === 2
                  ? "#19c37d"
                  : slot.status === 1
                  ? "#e0b800"
                  : "#e2e6ee";
              slotHtml += `<div title="Slot ${i} (status: ${slot.status})" style="width:18px;height:18px;border-radius:3px;background:${color};border:1px solid #d0d6e0;"></div>`;
            }
          }
          document.getElementById("diag-slotgrid").innerHTML = slotHtml;
          return;
        }
        // Live stats
        global.innerHTML = `
          <span class="metric"><b>Throughput</b>: ${
            stats.throughput?.toFixed(1) ?? "-"
          } msg/s</span>
          <span class="metric"><b>Lag</b>: ${stats.consumerLag ?? "-"} ms</span>
          <span class="metric"><b>Used</b>: ${stats.used ?? "-"} / ${
          stats.slots ?? "-"
        }</span>
          <span class="metric"><b>Free</b>: ${stats.free ?? "-"}</span>
          <span class="metric"><b>Conflicts</b>: ${
            stats.conflicts ?? "-"
          }</span>
          <span class="metric"><b>Errors</b>: ${stats.errors ?? "-"}</span>
          <span class="metric"><b>Reclaimed</b>: ${
            stats.reclaimed ?? "-"
          }</span>
        `;
        // Slot grid
        const N = stats.slots || 32;
        let slotHtml = "";
        if (stats.slotState) {
          for (let i = 0; i < N; i++) {
            const slot = stats.slotState[i] || { status: 0 };
            let color =
              slot.status === 2
                ? "#19c37d"
                : slot.status === 1
                ? "#e0b800"
                : "#e2e6ee";
            slotHtml += `<div title="Slot ${i} (status: ${slot.status})" style="width:18px;height:18px;border-radius:3px;background:${color};border:1px solid #d0d6e0;"></div>`;
          }
        } else {
          for (let i = 0; i < N; i++) {
            slotHtml += `<div style="width:18px;height:18px;border-radius:3px;background:#e2e6ee;border:1px solid #d0d6e0;"></div>`;
          }
        }
        document.getElementById("diag-slotgrid").innerHTML = slotHtml;
      }
      // Patch each test to start/end diagnostics for its channel
      window.runStressTest = async (btn) => {
        btn.disabled = true;
        const N = 5000,
          slots = 16,
          size = 80;
        let processed = 0,
          sent = 0;
        const { channel, buffer } = createChannel({
          slots,
          slotSize: size,
          sweepTimeoutMs: 40,
        });
        // No live diagnostics during the test
        const start = Date.now();
        // Producer
        const prod = setInterval(() => {
          for (let tries = 0; tries < 100 && sent < N; tries++)
            if (channel.send(encode({ i: sent }))) sent++;
        }, 0);
        // Consumer
        const cons = setInterval(() => {
          let msg;
          while ((msg = channel.recv())) processed++;
        }, 0);
        const timeout = 2500,
          t0 = Date.now();
        while (processed < N && Date.now() - t0 < timeout)
          await new Promise((r) => setTimeout(r, 10));
        clearInterval(prod);
        clearInterval(cons);
        const duration = Date.now() - start;
        document.getElementById("stress_result").innerHTML =
          (processed === N
            ? '<span class="success">PASS — '
            : '<span class="fail">FAIL — ') +
          `Processed ${processed}/${N} (${((processed / N) * 100).toFixed(
            1
          )}%)</span>`;
        document.getElementById(
          "stress_output"
        ).textContent = `Duration: ${duration} ms\nLost: ${N - processed}`;
        // Take a single diagnostics sample at the end
        const stats = channel.stats();
        const avgThroughput = duration > 0 ? processed / (duration / 1000) : 0;
        diagSummary = {
          peakThroughput: avgThroughput,
          avgThroughput,
          maxLag: 0,
          totalConflicts: stats.conflicts,
          totalErrors: stats.errors,
          totalReclaimed: stats.reclaimed,
          finalSlotState: [],
          slots,
        };
        diagTestActive = false;
        updateDiagnosticsDashboard();
        btn.disabled = false;
      };
      window.runReclaimTest = async (btn) => {
        btn.disabled = true;
        const slots = 12,
          size = 80;
        const { channel, buffer } = createChannel({
          slots,
          slotSize: size,
          sweepTimeoutMs: 10,
        });
        startDiagnostics({ buffer }, slots);
        Object.defineProperty(channel, "slotStatus", {
          value: channel["slotStatus"],
          writable: false,
          configurable: true,
          enumerable: false,
        });
        Object.defineProperty(channel, "slotClaimTimestamp", {
          value: channel["slotClaimTimestamp"],
          writable: false,
          configurable: true,
          enumerable: false,
        });
        for (let i = 0; i < slots / 2; i++) {
          channel.slotStatus[0][i] = 1;
          channel.slotClaimTimestamp[0][i] = Date.now() - 1000;
        }
        await new Promise((r) => setTimeout(r, 1000));
        const preReclaimed = 0;
        const stats = channel.stats();
        document.getElementById("reclaim_result").innerHTML =
          (stats.reclaimed > preReclaimed
            ? '<span class="success">PASS — '
            : '<span class="fail">FAIL — ') +
          `Slots Reclaimed: ${stats.reclaimed - preReclaimed}</span>`;
        document.getElementById("reclaim_output").textContent = `Reclaimed: ${
          stats.reclaimed - preReclaimed
        }, Errors: ${stats.errors}\nFree slots after: ${stats.free}`;
        // Use final stats for dashboard summary
        diagSummary = {
          peakThroughput: 0,
          avgThroughput: 0,
          maxLag: 0,
          totalConflicts: stats.conflicts,
          totalErrors: stats.errors,
          totalReclaimed: stats.reclaimed,
          finalSlotState: [],
          slots,
        };
        diagTestActive = false;
        updateDiagnosticsDashboard();
        btn.disabled = false;
      };
      window.runRaceTest = async (btn) => {
        btn.disabled = true;
        const producers = 12,
          consumers = 12,
          slots = 2,
          size = 80,
          N = 2000;
        let written = 0,
          read = 0;
        const { channel, buffer } = createChannel({
          slots,
          slotSize: size,
          sweepTimeoutMs: 30,
        });
        startDiagnostics({ buffer }, slots);
        channel.__getTestStats = () => ({
          errors: channel.errors,
          conflicts: channel.conflicts,
        });
        const start = Date.now(); // Record actual start time
        const prodInt = Array.from({ length: producers }, (_, p) =>
          setInterval(() => {
            for (let c = 0; c < 100 && written < N; c++)
              if (channel.send(encode({ w: written }, size))) written++;
          }, 1)
        );
        const consInt = Array.from({ length: consumers }, (_, c) =>
          setInterval(() => {
            let msg;
            while ((msg = channel.recv())) read++;
          }, 1)
        );
        const timeout = 3000;
        while (read < N && Date.now() - start < timeout)
          await new Promise((r) => setTimeout(r, 10));
        prodInt.forEach(clearInterval);
        consInt.forEach(clearInterval);
        const { conflicts, errors } = channel.__getTestStats();
        document.getElementById("race_result").innerHTML =
          (conflicts > 0 || errors > N / 2
            ? '<span class="success">PASS — '
            : '<span class="fail">FAIL — ') +
          `Conflicts detected: ${conflicts}, Errors: ${errors}`;
        document.getElementById(
          "race_output"
        ).textContent = `Produced: ${written}, Consumed: ${read}, Conflicts: ${conflicts}, Errors: ${errors}`;
        const duration = Date.now() - start; // Use actual measured duration
        const stats = channel.stats();
        const avgThroughput = duration > 0 ? written / (duration / 1000) : 0;
        diagSummary = {
          peakThroughput: avgThroughput,
          avgThroughput,
          maxLag: 0,
          totalConflicts: stats.conflicts,
          totalErrors: stats.errors,
          totalReclaimed: stats.reclaimed,
          finalSlotState: [],
          slots,
        };
        diagTestActive = false;
        updateDiagnosticsDashboard();
        btn.disabled = false;
      };
      window.runCorrectTest = async (btn) => {
        btn.disabled = true;
        const slots = 32,
          size = 80,
          N = 30;
        const sent = [],
          got = [];
        const { channel, buffer } = createChannel({
          slots,
          slotSize: size,
          sweepTimeoutMs: 50,
        });
        startDiagnostics({ buffer }, slots);
        for (let i = 0; i < N; i++) {
          const obj = { msg: i, rnd: Math.random() };
          sent.push(obj);
          channel.send(encode(obj, size));
        }
        let broken = null;
        const start = Date.now();
        for (let tr = 0; tr < 200 && got.length < N && !broken; tr++) {
          let out;
          while ((out = channel.recv())) {
            const obj = decode(out);
            got.push(obj);
            const ref = sent[obj.msg];
            if (!ref || ref.rnd !== obj.rnd) broken = obj;
          }
          await new Promise((r) => setTimeout(r, 50));
        }
        document.getElementById("correct_result").innerHTML = broken
          ? '<span class="fail">FAIL — Data Corruption!</span>'
          : got.length === N
          ? '<span class="success">PASS — All messages correct!</span>'
          : '<span class="fail">FAIL — Message Loss</span>';
        document.getElementById("correct_output").textContent =
          `Sent: ${N}, Received: ${got.length}, Fail? ${
            broken ? JSON.stringify(broken) : "No"
          }` +
          (broken
            ? `\nMISMATCH: got ${JSON.stringify(broken)} expected rnd=${
                sent[broken.msg] && sent[broken.msg].rnd
              }`
            : "");
        // Use final stats for dashboard summary
        const duration = Date.now() - start;
        const stats = channel.stats();
        const avgThroughput = duration > 0 ? got.length / (duration / 1000) : 0;
        diagSummary = {
          peakThroughput: avgThroughput,
          avgThroughput,
          maxLag: 0,
          totalConflicts: stats.conflicts,
          totalErrors: stats.errors,
          totalReclaimed: stats.reclaimed,
          finalSlotState: [],
          slots,
        };
        diagTestActive = false;
        updateDiagnosticsDashboard();
        btn.disabled = false;
      };
    </script>
  </body>
</html>
